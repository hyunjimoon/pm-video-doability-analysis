---
modified:
  - 2026-01-28T19:30:00-05:00
---
**Product Management Class: Video Transcript [Original]**

Hello students, my name is Andres. I'm one of your TAs for this class and today I'm going to be introducing briefly the project for this class. The product management project for this semester involves ideating, and also creating a prototype -- a working prototype of the app, product, or feature that's catered for your MBA community. And what I mean by a working app, product or feature is to have a working code base of the solution, so that people can actually use the product, click through the screens, and see what the customer journey looks like in the designed product, feature, app or solution.

The reason why we're so excited about this project is embodied by the tweet you're seeing right now on your screen. This is a tweet by Madhu Guru, who is the head of product at Google Cloud, in which he gives us a little taste of how the PM role is shifting at these big companies. So, as you can see, he says that at Google, the PM role is shifting from a writing-first culture to a building-first culture.  What that means is that previously PMs were thought of as these big strategic minds within a product organization, and they spent a lot of their time building Product Requirements Documents (PRDs) for engineers to work with. However, with the invention of vibe-coding tools, PMs are now more able to not only write the PRD documents, but also prototype the changes or the features of the desired products.  Such prototypes can engage engineers in a more natural manner:  Instead of just giving them these big PRD documents, prototypes actually show the engineers what features, tools, or apps that the PMs are thinking about building.

This is best embodied by this phrase that I think captures how the PM role is shifting. PMs now can (and should) “show and show not tell.” The PM role, with the invention of the vibe-coding tools, has gained the power of going beyond PRD documents and being involved with the actual code. So, this is true for big (and small) companies.  Something that's really eye-opening is to look into the job descriptions for many PM roles and see that many companies are expecting their PMs to have vibe-coding skills before even applying to the role. And this is even more critical for medium-sized companies and smaller startup companies in which PMs can even go from a prototyping skill to a deployment skill set, in which PMs sometimes are actually the ones who actually deploy code to their code base. And that's because at these smaller companies, engineering resources are even more limited.

So, we're really excited about this project because this is going to give you all hands-on experience on how to prototype products from scratch, which is a skill that's highly sought after for PMs today. This exercise and assignment will show you how these apps are built and what is meant by an app code base and what does that look like.   And it's going to give you the opportunity to work with the kind of tools that are being used by the industry leaders and that are becoming really essential for the PM role in the future.

So, some of you might be thinking right now, do I need any coding capabilities or any coding skills for me to do this project? The short answer is no. And the reason why you won't need this is because we're going to be leveraging vibe coding tools.  Before I get into the details about the tools that we're proposing you use, what vibe-coding means is tools that are able to translate natural language into code. So, natural language meaning just plain English into working code.

And we are proposing you to use Lovable and Cursor, which are becoming kind of industry standards in the vibe-coding community. However, feel free to use any vibe-coding tools that you might be used to or that you might know or that you might want to try. However, whatever tools you choose to use, one tool that it's going to be required for this project is to use GitHub. GitHub is not a vibe-coding tool in itself, but think of it like the Google Drive for the code that's going to be generated from these tools. So, the final deliverable from this project is the GitHub repository that you're going to be sharing with your TAs, so that TAs can actually use your tool and be able to assess the solution that you developed during the term.

So, what's Lovable and what is Cursor? Lovable gets its name from the concept of MVP, which I'm pretty sure many of you are already familiar with. So, MVP comes from minimum viable product.  In the industry, the MVP concept has gradually shifted to more of an MLP concept. MLP means minimum lovable product, and that's where Lovable gets its name. And what minimum lovable product means is that in the industry, people usually think what's the minimum product that I can create that customers will love. It's not what product is viable, but what product can customers love. And with that context in mind, Lovable has become really good at creating this first iteration of your app feature product idea. So, Lovable works great when (1) you have an idea in mind, and (2) you have already created content for the PRD document, and (3) you have a sense of what the customer journey is going to look like, and (4) you already have some design features in mind.  Then you can go into Lovable, tell Lovable all these things you have thought -- in plain English -- and Lovable will create the first iteration of the code base and the front end that's going to be the MLP of your of your version 1.0 of your app.

After you’ve created version 1.0 of your app, you can make changes in Lovable. So, if you want to include another screen or you want to create some changes in the first output, you can do that through Lovable. However, the industry standard on how to do these changes has become Cursor. So, think about Cursor as your software engineer friend. So, the way Cursor works is whatever your code base might be, you can go into Cursor and tell the app, 'I want to do this change' and then Cursor will do those changes into the code base provided by Lovable.

The reason why we need GitHub:  As you will see, the code that's going to be generated by Lovable is not just one script -- it's many, many different files. And the industry standard way to keep track of these files is to upload them into GitHub. And within GitHub, you can then keep track of the changes of the different features or changes that have been done in the app. And GitHub becomes this source of truth -- this base code of the app -- which maintains the master version of the code.

So, what we're going to do is to create a simple app through Lovable. We're going to put all the files in GitHub, and then we're going to connect our GitHub repository into Cursor. And with Cursor, we're going to do some changes and after we do those changes, we will send those changes back to GitHub. So you can see what's the usual workflow that you will have to follow.

So, GitHub will contain the final deliverable from your project. You will create a public repository that you will be sharing with your TAs -- and that repository is going to be the one that we are actually going to be grading. But it is expected that you will follow this workflow in which you create an app through Lovable and then do some changes through Cursor. So you actually get used to the vibe-coding tool apps that are being used in the industry right now.

So, now let's get into more of the details and how to use the apps. Lovable works as a webpage. You actually engage to Lovable through lovable.dev. And the way this works is that if you take a look at the project guide we have shared with you.   At the point in which you're first going to be using Lovable, you will have already created the PRD for your app, and you will have also created the customer journey for your app. So, you will have a lot of context for the app you're trying to build. And the reason why this is important is because Lovable is only as good as the context you give it -- to then go and create the code base for you.

So, within Lovable, the way, and in here I'm just having an example prompt. Uh the final prompt that you're supposed to be giving Lovable is going to be more detailed because at this stage in the project, as I said, you're going to have a lot more context about the app. But Lovable works great when you provide it detailed, detailed instructions of what you want to build. And in here I just have a basic structure of how the prompt might look like for you, but first you have to have your core idea of what the thing you want Lovable to build.

You also need a sense of the screens and functionality that you'll have designed for the customer journey. So, you're going to need all the screens that you are thinking to build. So, the... for the case I am ab out to illustrate, we have a home screen, a contact detail screen, an add new contact screen, and also the functionality that's going to be available on each of these screens. For a screen that's going to have a lot of the different user input, I'm also defining for Lovable a lot of the text of the input types that Lovable should be able to handle so that the app knows how to deal with the different inputs. And something that also it's also a best practice is to provide Lovable with some design notes of how it should design the the app. One thing that's really important is to provide the basic color palette that's going to be used for the app, so it's aligned with the MBA feature tool that you're designing.

I'm just going to provide this prompt to Lovable. I'm not going to skip through the video so you can see how much time Lovable spends building this app. So, I'm just going to provide this context to Lovable. As you can see, the way this works is a really familiar chatbot interface that we are used to from ChatGPT or Gemini, but it's just Lovable takes our prompt and then it starts thinking about how it's going to design this tool. And it's going to be... it might be able to... it might provide us with some questions that Lovable might have for it to create this tool. If it doesn't have any questions, then it's going to be... it's going to go directly into creating the solution.

One thing that you have to keep in mind is that Lovable creates web apps. And what that means is that the front end that Lovable is going to create, it's going to be based in HTML. So, all of the apps that it's going to create are viewable through any web browser, and we're going to see that when it's actually done with the preview. But if you go in here, you can actually start seeing the code that Lovable is going to be creating for this app. So, I'm just going to stop for now. I'm just going to leave Lovable running, so you can see how much time Lovable takes creating this first MLP, and we can take a look at the output, the kind of output that Lovable creates.

. . .

All right. So, now you can see what Lovable created, and this is the preview of what Lovable has created. And as you can see, I can click through my app and see the functionality of the features that I have designed. You can see that these are not dummy features, but they actually work and they're really polished in a sense of this wasn't possible just a year before, but with the invention of these vibe-coding tools, it's really quite amazing the things that you can do in just a minute or so.

So, as I told you before, this is the preview of the app that you can see has the functionality that we provided on the first steps of the app. As I said before, you can even go and tell Lovable, 'Hey, I need to do these changes' on the app. That's a way things work really well. Uh however, if you want to do some uh code-heavy changes, then it might not work as great, and that's where uh Cursor might be a little bit more useful. So, that's the tool we're going to be using for our project or for this demo of how we think you should be building the project.

Before we get into that, I just wanted to show you a little bit of this in the app.   This is the preview, right? But all the code that's created for this app to work is in the code tab. And as you can see, it's not one or two files, it's actually many, many files. Which serves to prove like the capacity and how good these vibe-coding tools have become because in just a minute or so, we were able to create this much code and create a great-looking app that before would have taken us maybe a week or so of engineering resources to build.

So, one thing that you'll notice is that within Lovable, getting your project to GitHub is quite easy. You have **here** your connect to GitHub button. But, before you actually do this, you should go into the GitHub webpage and create a GitHub account. It's completely free and it's the industry standard when it comes to building your code repositories. I'm just going to show you a little bit of how GitHub looks.

So, this is the GitHub repository that I have for some of the projects I've been building before.  What I mean by repository -- think about repositories as your individual code bases. So, in here, I have three different code bases for different projects that I've been working on. You can see that I have the code for many of the different projects and this is just the way projects are stored within the industry. So, whenever you think about any app, any feature, any tool, there's probably a GitHub repository in which developers work. So, how this usually works is that engineers connect to GitHub repositories and then they do changes, and then they upload their changes to the GitHub repository and then the code base is updated.  This is kind of the industry standard when it comes to how to work with code.

So, once you've created your your GitHub repository, you can **actually click in here,** connect your GitHub repository, and you can say 'Connect project'. And when you connect the project to your GitHub repository, you are going to see that you're going to have a new repository created in your GitHub base. So, if I go into **here**, as you can see, we didn't have this MIT cohort finder before. But now when I click in it... click on it, I can see that all the different files that were created by Lovable are now included into my GitHub repository.

One little thing that you should also know before moving forward with Cursor is you should also install Git. Git is the way in which GitHub interacts with the local files. So, if you run into any kind of problems, first install Git before creating your GitHub um account.  Explain how to install Git?

So, now we have a basic structure of our of our app. Now we can go into Cursor to see a little bit more about the code, and actually see how Cursor works and how we can actually create some changes within our created app.  The easiest way to do this is to clone your repository. **CLARIFY:**  So, you... If you connect the... the same way you can connect your GitHub repository in Lovable, you can do in Cursor. So, if you connect your... it's just a matter of providing your login... login and password. Once you do that, you're going to be able to see all the different projects that are in your GitHub repository and you can actually click through the one we just created. You need to provide Cursor with the folder in which to save all these files. So, I'm just going to put here 'Demo Product Management Project'. So, you create a folder within your local files. You select that as a repository. And what it does is that Cursor is going to download all the app... all the files that were created by Lovable into your computer, so it can actually work within with the code base that you have provided.

So, once you do that, what you're going to see is that all the files that were created by Cursor are going to be located here. And you can actually go and see the different codes that are basically your app. So, when you think about your app and the thing we saw in Lovable, it's just this code that the computer runs and it's able to show the app on an HTML browser such as Google Chrome.

So, once you have this, what I really like to do is to get a sense of how my app works. And the way you can do that is within Cursor, you're going to have this new chat tab here in which this new chat tab is how you engage with Cursor. And I told you before, think of Cursor as a software engineer friend that's always available to explain things to you, but also to do changes in the app as you see fit. So, in here I can go ahead and tell... 'Explain to me how my app works ... and what my files do'. So, you engage with Cursor in natural language, and you can see how Cursor is then going to go through your code base, it's going to read through all the different files that Lovable created, and then it's going to tell you, 'Hey, look, this is what I found'. So, it's really useful for you to see, 'Hey, these are the files that Lovable created. Now I want to understand how this app works'. And Cursor does that really, really easy for you by just having a chatbot interface.

So, you can go into the details on how this works. But before we do that, I just wanted to show you how can we go from this code to the actual app that we saw in Lovable. So, for to do this, we're going to go into a terminal. You open a terminal by going to the terminal, new terminal button up on Cursor. And then you're going to run this command that's called **_'npm install'_**. What 'npm install' does, it it installs all the libraries and the repositories that were needed for us to actually run the app. And once it does that, you can go ahead and say **_'npm run dev'_**. And what this does, it creates a local host in your computer in which you're going to be able to see the app that we created in Lovable. So, this is the exact app we created in Lovable, and you can see I can click through it, I can engage with it. I can go and... through LinkedIn, I can do... See all the functionalities that I parsed through Lovable live here in the app.

And what's really useful right now is that once you thought about your customer journey, there might be some customer journey changes that you want to do on your app, or there might be some design changes that you might do on your app that we're going to be doing through Cursor. So, as a matter of example, let's say this app would look better if I had my MIT logo here, right? So, I'm just going to go ahead and see and search 'MIT Sloan logo'. Search for a logo. This is a good logo. And I know that I can copy the link address of this image, which if I go into this image... into this URL... Sorry, it didn't work. So... uh... What I'm trying to get at is... uh... copy image address. So if I go into image address, I can see that this address has the logo that I want to put in my app. So, the way I would go about that is I can go into Lovable and actually say, 'I want my app to have on the upper right corner an MIT Sloan logo that is on this URL'.

And what you're going to see is that Cursor works so well with natural language that it takes your input, it plans the next moves. Since you already told Lovable (or did you mean **Cursor?)** to explain how this app works, it already has in the context how... what files should it change. So, it knows what to do. So, think about Cursor as your software engineer friend that's always available to do the changes for you. So, you can see it's just working through those changes in... and when it... everything's done, it's going to tell you, 'Hey, I made the changes, everything is good.' And now we can go back to our app. And we can see that it now created the MIT Management logo. It has put it here. I wanted it here. So, I can go ahead and, 'Hey, I wanted it to be on the left side hand of this text'. So, 'the logo to be on the left hand side of this text'.

Now, Cursor only works as well as the prompt you provide it. So, whenever you provide it with an ambiguous prompt, such as the first prompt that I gave Lovable, then you can see it makes some decisions that might not be the right ones. So, it put the logo first on on the right-hand side of the of the app. But if you run into those problems, you can actually have a conversation with Lovable and finally it's going to be understanding what the changes that you're trying to do uh actually entail. So, now you can see that by just providing natural language to Cursor, Cursor was able to do the change that I wanted and and do it in the app.

Now, this was a simple change, but Cursor can also do more structural changes, like creating different screens. Maybe I want an add contact, but I can also want a delete contact from button here. So, those kind of changes that you have thought during your customer journey plan, you can you can build those changes with Cursor. I'm... was just trying to show you a simple example to see how Cursor works and how you should engage with Cursor within your project.

So, within Cursor, you have to work on all the changes that you've thought about that entail a beautiful customer journey and that captures all the elements of the PRD that you have thought about before, in your ideation stage of the project. But at the end, as I have previously mentioned, what we are expecting you to provide us is the GitHub repository in which all these changes are... were made. So, all the things you've done in Cursor up to now are saved in the repository that we created on the beginning in our computer. So, all the changes are local to the files within our computer.

So, the next... after you do all the changes in Cursor, what you have to do is have these changes reflected on your GitHub repository. And the way we go about that is we create a new terminal and we run these commands. So, first we go through **_'git status'_**. 'git status' is going to tell us what we have modified. So, in here it tells us, 'Hey, you have modified the index.tsx file', which we did to change the MIT logo appearance. So, we now have to add these changes to our repository. So, **we run the command 'git add .'**, which basically means that all these changes are going to be added. So, all the changes have been changed in the code. And then we are going to put... **we're going to do our first 'git commit'**. So, basically this command what it's saying is that, 'Hey, we're going to do be making this commit to the Git repository. We can put a comment on what this change was. So, **'add the MIT Sloan logo to the app'.**

This is not needed for the project, but think if you were working in a real company with many engineers working on the app at the same time -- having a little comment of what the comment is about is really useful. So, once you do that, then you can finally put your final Git command that's going to be pushing these changes to the source code. So, **'git push origin main'** is a really strong command because it's going to alter your GitHub code permanently. So, be sure that whenever you run this command, it's because all the changes you've done in your Cursor code base were the ones you really wanted because going back from this change is really, really hard. So, once you click that... Oh, I misspelled origin. **???**

Once you do that, your GitHub repository was changed with the changes you've done in your Cursor tool. And now that final GitHub repository (with all the cahnges yu wat ot make) is the one you're going to be sharing with your TAs. So, this was a brief introduction about the kind of tools you are expected to be using during the project. As we said previously, we're really excited about this project because it's going to provide you with important skills valued right now in the job market, which are prototyping for PMs, but also having a lot of sense of the technicalities that go on... that... that building one feature app or tool actually require.

So, really excited about this project. Whenever you build your first tool or app, this is a huge eye-opening experience. And hopefully this is going to provide... this is going to be first a really teachable moment ... a really teachable experience for everyone here in the in the class and that you're going to enjoy and hopefully you're going to be using in your PM career. So, any questions, comments or problems you're having with uh building this this project, feel free to shoot an email to any of your TAs and they'll be happy to answer any of your questions.  All right, thank you all.