# Product Management Class: Video Transcript [Charlie's Edit]

**ðŸŽ¥ Revised Video Script: "PM Prototyping with Lovable & Cursor"**

**(00:00) Introduction & The Project Goal**

"Hello, students. My name is Andres, and I'm one of your TAs. Today, I'm going to briefly introduce the main project for this class. As you may know, this semester's product management project involves not just ideating, but also creating a **working prototype** of an app, product, or feature catered to our MBA community.

By 'working prototype,' we mean a functional code base that allows users to navigate the product, click through screens, and experience the customer journey you've designed."

---

**(00:30) The "Why": The Shift in the PM Role**

"We are particularly excited about this project, and the reason is embodied by this tweet you're seeing from Madhu Guru, the Head of Product at Google Cloud. He gives us a glimpse of how the PM role is shifting at major tech companies.

He notes that at Google, the PM role is shifting from a 'writing-first' culture to a 'building-first' one. Previously, PMs were seen as the strategic minds who spent most of their time writing detailed Product Requirements Documents (PRDs) for engineers. However, with the rise of **biv-coding tools**, PMs can now go beyond writing PRDs.

They can _actually_ prototype the features themselves. This allows them to engage with engineers more naturallyâ€”not just by handing them a document, but by **showing** them a working concept."

---

**(01:15) "Show, Don't Tell" & Job Market Relevance**

"This shift is best captured by the phrase: **'PMs can now show, not just tell.'** The invention of biv-coding tools has empowered PMs to be more directly involved with the code, moving beyond just documentation.

This is true at large companies, and you'll even see it in job descriptionsâ€”many now expect PMs to have basic biv-coding skills. This is even more critical at startups and medium-sized companies where engineering resources are limited. There, a PM's skill can shift from just prototyping to actual deployment, with PMs sometimes deploying code directly to the code base."

---

**(02:00) Project Goals & The "No-Code" Prerequisite**

"So, we're excited because this project will give you hands-on prototyping experienceâ€”a critical skill for modern PMs. You'll gain a deep understanding of how apps are built, what a 'code base' actually looks like, and you'll get to use the same tools industry leaders are adopting.

Now, you might be thinking: 'Do I need coding skills for this project?' The short answer is **no**. The reason is that we will be leveraging **biv-coding tools**. Biv-coding refers to tools that can translate natural languageâ€”just plain Englishâ€”into working code."

---

**(02:45) Introducing the Toolset: Lovable, Cursor, and GitHub**

"We are proposing you use **Lovable** and **Cursor**, which are becoming industry standards in this space. You are free to use other vibe-coding tools you're familiar with, but one tool is mandatory for everyone: **GitHub**.

GitHub itself isn't a vibe-coding tool. Think of it as the Google Drive for your code. The final deliverable for this project will be your GitHub repository, which you'll share with the TAs so we can run your tool and grade your solution."

---

**(03:25) What is Lovable (MLP)?**

"So, what are Lovable and Cursor?

Lovable gets its name from a concept you're likely familiar with: MVP, or Minimum Viable Product. In the industry, this concept has evolved into **MLP**, or **Minimum Lovable Product**. The question shifted from 'What is viable?' to 'What is the minimum product customers will _love_?'

With that context, Lovable excels at creating the **first iteration** of your app idea. It works best when you've already done your homework: you have a PRD, you've mapped the customer journey, and you have design ideas. You feed all of this context to Lovable in plain English, and it generates the front-end and code base for your version 1.0â€”your MLP."

---

**(04:15) What is Cursor (The "Engineer Friend")?**

"Now, you _can_ make changes directly in Lovable after that first build. However, the industry standard for iterating on an existing code base is a tool like **Cursor**.

Think of Cursor as your **software engineer friend**. It works by importing an entire code base. You can then simply tell it, in natural language, 'I want to make this change,' and it will modify the code for you."

---

**(04:45) The Full Workflow: Lovable -> GitHub -> Cursor**

"This is where GitHub is essential. The code generated by Lovable isn't one file; it's _many_ files. GitHub is the standard way to store these files, keep track of changes (which is called version control), and maintain the 'source of truth' or the master version of the code.

So, here is the workflow we'll follow:

1. First, we'll **create** a simple app in Lovable.
2. Second, we'll **push** all the project files to a new repository on GitHub.
3. Third, we'll **connect** that GitHub repository to Cursor.
4. Fourth, we'll **make changes** using Cursor.
5. Finally, we'll **push** those changes back to GitHub.

This workflow will familiarize you with the tools and processes used in the industry."

---

**(05:35) Step 1: Using Lovable (The Prompt)**

"Alright, let's get into the details. Lovable is a web app, accessible at lovable.dev. By the time you use Lovable, you should already have your PRD and customer journey mapped out. This context is critical, because **Lovable is only as good as the prompt you give it.**

I'm using a simple example prompt here, but yours should be much more detailed. Lovable works best with highly detailed instructions. A good prompt structure includes:

1. The **core idea** of your product.
2. A breakdown of all **screens and their functionality**, based on your customer journey.

For my example, I'm defining a home screen, a contact detail screen, and an 'add new contact' screen. For screens with user input, I'm specifying the input types Lovable should handle. Finally, it's a best practice to provide **design notes**, especially a basic color palette, to keep it aligned with your product's brand."

---

**(06:40) Running Lovable (Live Demo)**

"I'm going to paste this prompt into Lovable now. I won't skip this part so you can see how long it actually takes. The interface is a familiar chatbot, similar to ChatGPT or Gemini. Lovable takes the prompt and starts planning the app structure. It might ask clarifying questions if your prompt is ambiguous. If not, it will just start building.

Keep in mind that Lovable creates **web apps**. The front end is built in HTML, so the apps it generates are viewable in any web browser. As it works, you can even peek at the 'Code' tab to see the files being generated in real-time.

Okay, I'll let Lovable run and we'll check back in when the first buildâ€”our MLPâ€”is complete."

---

**(07:30) Reviewing the Lovable Output (MLP)**

"Alright, Lovable is finished. You can see the preview it generated. I can click through the app and interact with the features I designed. These aren't dummy buttons; they actually work. The level of polish is incredible, especially considering this technology wasn't really possible a year ago.

As I mentioned, you _can_ continue iterating by giving Lovable new prompts, like 'I need to do these changes.' This works well for simple adjustments. But for more complex, code-heavy changes, Cursor is the better tool, which we'll use next.

Before we move on, look at the 'Code' tab. This is all the code created for the app. It's not one or two files; it's a complete project structure. In just a minute, Lovable generated what might have taken an engineering team a week to build from scratch."

---

**(08:35) Step 2: Connecting to GitHub**

"Getting your project from Lovable to GitHub is very easy. First, if you haven't, go to GitHub.com and create a free account. It's the industry standard for code repositories.

_(Show GitHub)_ Here's my GitHub profile. Think of 'repositories' as individual folders for each of your code bases. Every app or feature you can think of almost certainly lives in a GitHub repository somewhere.

Once your account is ready, just click the 'Connect to GitHub' button in Lovable and authorize it. When you click 'Connect project,' Lovable will automatically create a **new repository** in your GitHub account and push all the files.

If I refresh my GitHub page, you can see the new repository 'MIT-cohort-finder' is here. And inside, all the files generated by Lovable are now stored.

One quick prerequisite: Before you do this, make sure you have **Git** installed on your computer. Git is the underlying technology that GitHub uses to manage file versions locally. Install Git _before_ you create your GitHub account to avoid any issues."

---

**(09:50) Step 3: Connecting GitHub to Cursor**

"Okay, we now have our app's code base on GitHub. The next step is to open it in Cursor. The easiest way is to 'clone' the repository. Just like in Lovable, you can connect your GitHub account directly to Cursor by providing your login credentials.

Once connected, Cursor will show all the repositories from your GitHub. I'll select the 'MIT-cohort-finder' we just created. Cursor needs a folder on your computer to save these files locally. I'll create a new one called 'Demo Product Management Project' and select it.

Cursor will now downloadâ€”or 'clone'â€”all the files from the GitHub repository to that folder on your computer. Now, you can see that same file structure from Lovable and GitHub, right here in Cursor's file explorer."

---

**(10:40) Using Cursor (The "Engineer Friend")**

"Now that the project is open, the first thing I like to do is get a sense of how it works. You interact with Cursor using this 'New Chat' tab. Remember, think of it as your software engineer friend.

I can just ask it in natural language: **'Explain to me how my app works and what my files do.'**

Cursor will scan the entire code base, read the files, and then give me a high-level summary. This is incredibly useful for understanding a code base you didn't write yourself."

---

**(11:20) Running the App Locally**

"So, how do we see the app running from this code? We need to open a terminal. You can do this right in Cursor by going to 'Terminal' > 'New Terminal.'

1. First, type npm install. This command installs all the necessary libraries and dependencies the project needs to run.
2. Once that's done, type npm run dev. This command builds the app and starts a local server.

This opens the app in my browser. As you can see, this is the _exact same app_ we built in Lovable, but now it's running locally on my computer. I can click through it and see all the functionality."

---

**(12:10) Step 4: Making Changes with Cursor (Live Demo)**

"What's powerful about this is that we can now make changes and see them live. Let's say I decide the app needs our MIT Sloan logo in the header.

I'll find a logo online and copy the image address. Now, I go back to the chat in Cursor and just... tell it what I want: **'I want my app to have an MIT Sloan logo in the upper right corner, using this URL.'**

Cursor takes my natural language prompt, plans the changes, and because it already read my code base, it knows _exactly_ which files to modify. It's working on those changes right now...

Okay, it's done. If I go back to my app preview... there's the logo. But, it put it on the right, and I actually wanted it on the left of the text. This highlights an important point: **Cursor is only as good as your prompt.** My first prompt was a bit ambiguous.

No problem. I can just have a conversation with it. I'll type: **'Put the logo on the left-hand side of this text.'** It will re-evaluate and make the new change.

And now... you can see, just by talking to it, Cursor fixed the layout and did exactly what I wanted.

This was a simple design change, but Cursor can handle major structural changes, tooâ€”like adding a 'Delete Contact' button or building entirely new screens based on your customer journey."

---

**(14:00) Step 5: Pushing Changes Back to GitHub (Git Workflow)**

"As I mentioned, the final deliverable is your GitHub repository. Right now, all the changes we just made in Cursor are only saved **locally** on my computer. They don't exist on GitHub yet. We need to push these local changes back to our GitHub repository.

To do this, we use a few simple Git commands in the terminal.

1. First, git status. This tells us which files have been modified. You can see it correctly identifies that 'index.tsx' was changed.
2. Next, git add . (that's 'git add' space 'period'). This command 'stages' all the modified files, preparing them to be saved.
3. Then, we 'commit' the changes with a message: git commit -m "Add MIT Sloan logo to app". This command takes a snapshot of the staged files. The message explains _what_ change was made, which is essential when working on a team.
4. Finally, git push origin main. This is the command that **sends your local changes up to the GitHub repository**. Be careful with this commandâ€”it permanently alters your 'main' branch. Make sure your changes are correct before you push.

And... it's done. Now, if I go back to my GitHub repository online and refresh the page, you can see the commit message 'Add MIT Sloan logo to app.' The code on GitHub is now updated with the changes we made in Cursor."

---

**(15:45) Conclusion & Final Thoughts**

"So, that was a brief introduction to the workflow and the tools for this project. We are genuinely excited about this, as it will provide you with the exact prototyping and technical skills that are in high demand for PMs right now.

Building your first app is a huge, eye-opening experience. We hope this is a valuable learning opportunity, one that you'll enjoy and that will provide you with skills you'll use throughout your entire PM career.

If you have any questions or run into any problems, please feel free to email any of your TAs. We'll be happy to help. Thank you all."